---------------------------------Mergesort----------------------------------------------

merge :: [Int] -> [Int] -> [Int]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys) | x <= y = x:merge xs (y:ys)
                                        | otherwise = y:merge ys (x:xs)
 
 
split :: [a] -> Int -> ([a], [a])
split [] _ = ([], [])
split [x] _ = ([x], [])
split l p =  ([a | a <- take p l],[b | b <- drop p l])
                                       
                                                                       
mergesort :: [Int] -> [Int]
mergesort [] = []
mergesort [x] = [x]
mergesort (xs) =        let (a,b) = split xs (div (length xs) 2)
					in merge (mergesort a) (mergesort b)
					
-- Complexidade mergeSort: log n significa log do tamanho da lista na base 2, ex: log 8 = 3 porque 3^2=8.
-- Se a lista tiver n elementos vamos dividir essa lista (fase split) log n vezes, exemplo: [8,7,6,5,4,3,2,1] 
-- vai virar [8,7,6,5], [4,3,2,1], depois [8,7], [6,5] , [4,3], [2,1], depois [8],[7],[6],[5],[4],[3],[2],[1],
-- ou seja: foram necessários 3 splits ou melhor: log n splits. Daí fazemos os merges que vão comparar os elementos 1 a 1,
-- depois 2 a 2, depois 4 a 4 e assim por diante até que se compare tudo (log n vezes) e cada merge não chega a ter
-- n comparações, logo cada merge é O(n), e fazemos merges log n vezes, então a complexidade doo mergesort é (n log n)

---------------------------------Fim de Mergesort---------------------------------------

----------------------------------------------------Heapsort------------------------------------------------------------------

pegaElemento :: Int -> [Int] -> Int
pegaElemento 1 (a:as) = a
pegaElemento x (a:as) = pegaElemento (x - 1) (as)
 
pai :: Int -> [Int] -> Int
pai 1 (a:as) = a
pai x (a:as) = pegaElemento (div x 2) (a:as)
 
swap :: Int -> Int -> [Int] -> [Int]
swap x1 x2 l =  inicio x1 l ++ [pegaElemento x2 l] ++ meio x1 x2 l ++ [pegaElemento x1 l] ++ fim x2 l
 
heap :: Int -> [Int] -> [Int]
heap x l
        | x == (length l) + 1 = l
    | pegaElemento x l <=  pai x l = heap (x + 1) l
    | otherwise = heap (div x 2) (swap (div x 2) x l)
 
inicio :: Int -> [Int] -> [Int]
inicio 1 l = []
inicio x (a:as) = a : inicio (x - 1) as
 
meio :: Int -> Int -> [Int] -> [Int]
meio p f (a:as)
    | p >= 1 = meio (p - 1) (f-1) as
    | f > 1 = a : meio p (f-1) as
    | otherwise = []
 
fim :: Int -> [Int] -> [Int]
fim x (a:as)
    | x > 1 = fim (x - 1) as
    | otherwise = as
 
sort :: [Int] -> [Int]
sort [] = []
sort l = heapSort (broke l) ++ [pegaElemento 1 l]
 
broke :: [Int] -> [Int]
broke [] = []
broke (a:as) = as
 
heapSort :: [Int] -> [Int]
heapSort [] = []
heapSort l = sort (heap 1 l)

-- Complexidade do heapSort: Primeiro se constrói um heap em tempo log n pois o heap é uma árvore, colocando os maiores
-- elementos em cima dos menores elementos (Árvores tem altura log n), exemplo: uma árvore com 8 elementos tem altura 3.
-- Em seguida vai se tirando a raiz do heap a cada iteração, o maior valor já vai pro final da lista q será retornada
-- e o heap eh organizado novamente em tempo log n, e assim vai n vezes porque são n elementos, logo a complexidade é (n log n)

-------------------------------------------------------Fim de Heapsort--------------------------------------------------------


--------------------------Aqui começam os exercícios da aula 03---------------------------------------

menorMaior:: Int -> Int -> Int -> (Int, Int)
menorMaior x y z | (x <= y), (x<=z), (y<=z) = (x,z)
                 | (x <= y), (x<=z), (z<=y) = (x,y)
				 | (y <= x), (y<=z), (x<=z) = (y,z)
				 | (y <= x), (y<=z), (z<=x) = (y,x)
				 | (z <= x), (x<=y), (y<=x) = (z,x)
				 | (z <= x), (x<=y), (x<=y) = (z,y)

ordenaTripla:: (Int,Int,Int) -> (Int,Int,Int)
ordenaTripla (x,y,z) | (x <= y), (x<=z), (y<=z) = (x,y,z)
                     | (x <= y), (x<=z), (z<=y) = (x,z,y)
				     | (y <= x), (y<=z), (x<=z) = (y,x,z)
				     | (y <= x), (y<=z), (z<=x) = (y,z,x)
				     | (z <= x), (x<=y), (y<=x) = (z,y,x)
				     | (z <= x), (x<=y), (x<=y) = (z,x,y)





















